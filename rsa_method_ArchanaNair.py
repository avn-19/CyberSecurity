# -*- coding: utf-8 -*-
# Author Details :- Archana Nair, Manipal Institute of Technology, Reg No. 220928003
"""RSA-method.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e7qrDkXYN9Gyin4GM2ELyYJsNTYVnJm1
"""

from pickle import STOP
import random
import math
 
# A set will be the collection of prime numbers,

y =1
phi = None

global palintext, ciphertext, private_key, public_key,num

    
# numbers are co-prime or not
  
# Recursive function to
# return gcd of a and b

def __gcd(a, b):
  
    # Everything divides 0 
    if (a == 0 or b == 0): return 0
      
    # base case
    if (a == b): return a
      
    # a is greater
    if (a > b): 
        return __gcd(a - b, b)
              
    return __gcd(a, b - a)
  
# Function to check and print if 
# two numbers are co-prime or not 
def coprime(a, b):
      
    if ( __gcd(a, b) == 1):
        print("Co-Prime")
        return 1
    else:
        print("Not Co-Prime") 
        print("Cannot compute as numbers are not Co-prime")
        return -1    
  

def prime_checker(p):
	# Checks If the number entered is a Prime Number or not
	if p < 1:
		return -1
	elif p > 1:
		if p == 2:
			return 1
		for i in range(2, p):
			if p % i == 0:
				return -1
			return 1
    
def private_exponent(p,q,e):
  global public_key, private_key, phi,num,plaintext 
  public_key = e
  phi = (p-1)*(q-1)
  num = p*q
  if (public_key < phi):
      if coprime(public_key, phi)== 1:
         multiinv(public_key,phi)
         d = private_key
         plaintext=(int(input("Enter plaintext: ")))
         fastexp_cipher(plaintext,num,public_key) 
         return d     
      else:
         return -1
  else:
    print(f"Enter public exponent e(public_key) less than phi {phi}")
  return -1

  
# Modular Multiplicative Inverse
def multiinv(a,b):
    global private_key
    i=0
    r1 = b
    r2 = a
    t1, t2 = 0,1
    while r2 > 0 :
      remainder = r1 % r2 # get remainder
      q = r1 // r2 # get quotient 
      t = t1 - (q * t2) 
      r1 = r2
      r2 = remainder
      t1 = t2
      t2 = t
      i+= 1
      print(i,"interation values: ",r1 , r2, t1 , t2 , )
      if (t1 <0):
          private_key = t1 + t2
      else:
          private_key = t1
    print("inverse of",a,"mod",b,": ", private_key)
    print("private exponent d : ", private_key)
    return private_key

# Fast exponentiation in congruences
def fastexp_cipher(a,b,n):
   global y,ciphertext
   while n>=1:
      r = n % 2 # get remainder using mod function2
      if r == 1:
         y = (a*y) % b # calculate y value when bit =1
      a = (a*a) % b # calculate a value 
      n =n // 2 # n get quotient value
      print(y , n , r)
   ciphertext = y
   print("ciphertext: ",ciphertext )
   y=1
   if(plaintext != 0):
            fastexp_plain(ciphertext,num,private_key )

def fastexp_plain(a,b,n):
   global y, ciphertext
   while n>=1:
      r = n % 2 # get remainder using mod function
      if r == 1:
         y = (a*y) % b # calculate y value when bit =1
      a = (a*a) % b # calculate a value 
      n =n // 2 # n get quotient value
      print(y , n , r)
   plaintext = y
   print("plaintext: ", plaintext)
   y=1

# Input Data 

#choice= input("Do you want to calculate RSA: ")  


while 1:
	p = int(input("Enter 1st prime number p : "))
	if prime_checker(p) == -1:
		print("Number Is Not Prime, Please Enter Again!")
		continue
	break    

while 1:
	q = int(input("Enter 2nd prime number q : "))
	if prime_checker(q) == -1: 
		print("Number Is Not Prime, Please Enter Again!")
		continue
	break  

while 1:
  e=int(input("Enter public exponent: "))
  if private_exponent(p,q,e)==-1 :
     print("Please enter correct value of e")
     continue
  break